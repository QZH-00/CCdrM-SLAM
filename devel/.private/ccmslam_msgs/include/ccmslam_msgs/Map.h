// Generated by gencpp from file ccmslam_msgs/Map.msg
// DO NOT EDIT!


#ifndef CCMSLAM_MSGS_MESSAGE_MAP_H
#define CCMSLAM_MSGS_MESSAGE_MAP_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <ccmslam_msgs/KF.h>
#include <ccmslam_msgs/KFred.h>
#include <ccmslam_msgs/MP.h>
#include <ccmslam_msgs/MPred.h>

namespace ccmslam_msgs
{
template <class ContainerAllocator>
struct Map_
{
  typedef Map_<ContainerAllocator> Type;

  Map_()
    : header()
    , mMsgId(0)
    , Keyframes()
    , KFUpdates()
    , MapPoints()
    , MPUpdates()
    , vAckKFs()
    , vAckMPs()
    , WeakAckKF(0)
    , WeakAckMP(0)
    , ClosestKf_Id(0)
    , ClosestKf_ClientId(0)  {
    }
  Map_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , mMsgId(0)
    , Keyframes(_alloc)
    , KFUpdates(_alloc)
    , MapPoints(_alloc)
    , MPUpdates(_alloc)
    , vAckKFs(_alloc)
    , vAckMPs(_alloc)
    , WeakAckKF(0)
    , WeakAckMP(0)
    , ClosestKf_Id(0)
    , ClosestKf_ClientId(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _mMsgId_type;
  _mMsgId_type mMsgId;

   typedef std::vector< ::ccmslam_msgs::KF_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::KF_<ContainerAllocator> >> _Keyframes_type;
  _Keyframes_type Keyframes;

   typedef std::vector< ::ccmslam_msgs::KFred_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::KFred_<ContainerAllocator> >> _KFUpdates_type;
  _KFUpdates_type KFUpdates;

   typedef std::vector< ::ccmslam_msgs::MP_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::MP_<ContainerAllocator> >> _MapPoints_type;
  _MapPoints_type MapPoints;

   typedef std::vector< ::ccmslam_msgs::MPred_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::MPred_<ContainerAllocator> >> _MPUpdates_type;
  _MPUpdates_type MPUpdates;

   typedef std::vector<uint16_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint16_t>> _vAckKFs_type;
  _vAckKFs_type vAckKFs;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _vAckMPs_type;
  _vAckMPs_type vAckMPs;

   typedef uint16_t _WeakAckKF_type;
  _WeakAckKF_type WeakAckKF;

   typedef uint32_t _WeakAckMP_type;
  _WeakAckMP_type WeakAckMP;

   typedef uint16_t _ClosestKf_Id_type;
  _ClosestKf_Id_type ClosestKf_Id;

   typedef uint8_t _ClosestKf_ClientId_type;
  _ClosestKf_ClientId_type ClosestKf_ClientId;





  typedef boost::shared_ptr< ::ccmslam_msgs::Map_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ccmslam_msgs::Map_<ContainerAllocator> const> ConstPtr;

}; // struct Map_

typedef ::ccmslam_msgs::Map_<std::allocator<void> > Map;

typedef boost::shared_ptr< ::ccmslam_msgs::Map > MapPtr;
typedef boost::shared_ptr< ::ccmslam_msgs::Map const> MapConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ccmslam_msgs::Map_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ccmslam_msgs::Map_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ccmslam_msgs::Map_<ContainerAllocator1> & lhs, const ::ccmslam_msgs::Map_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.mMsgId == rhs.mMsgId &&
    lhs.Keyframes == rhs.Keyframes &&
    lhs.KFUpdates == rhs.KFUpdates &&
    lhs.MapPoints == rhs.MapPoints &&
    lhs.MPUpdates == rhs.MPUpdates &&
    lhs.vAckKFs == rhs.vAckKFs &&
    lhs.vAckMPs == rhs.vAckMPs &&
    lhs.WeakAckKF == rhs.WeakAckKF &&
    lhs.WeakAckMP == rhs.WeakAckMP &&
    lhs.ClosestKf_Id == rhs.ClosestKf_Id &&
    lhs.ClosestKf_ClientId == rhs.ClosestKf_ClientId;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ccmslam_msgs::Map_<ContainerAllocator1> & lhs, const ::ccmslam_msgs::Map_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ccmslam_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::ccmslam_msgs::Map_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ccmslam_msgs::Map_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ccmslam_msgs::Map_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ccmslam_msgs::Map_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ccmslam_msgs::Map_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ccmslam_msgs::Map_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ccmslam_msgs::Map_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b75f9043a42e539da365451900525c5c";
  }

  static const char* value(const ::ccmslam_msgs::Map_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb75f9043a42e539dULL;
  static const uint64_t static_value2 = 0xa365451900525c5cULL;
};

template<class ContainerAllocator>
struct DataType< ::ccmslam_msgs::Map_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ccmslam_msgs/Map";
  }

  static const char* value(const ::ccmslam_msgs::Map_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ccmslam_msgs::Map_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"uint32 mMsgId\n"
"\n"
"KF[] Keyframes\n"
"KFred[] KFUpdates\n"
"MP[] MapPoints\n"
"MPred[] MPUpdates\n"
"\n"
"#bool bAck\n"
"#uint32 Ack #should not be necessary any more\n"
"uint16[] vAckKFs\n"
"uint32[] vAckMPs\n"
"uint16 WeakAckKF\n"
"uint32 WeakAckMP\n"
"\n"
"uint16 ClosestKf_Id\n"
"uint8 ClosestKf_ClientId\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/KF\n"
"bool bSentOnce\n"
"\n"
"uint16 mnId # unique KF id\n"
"uint8 mClientId # client id\n"
"uint32 mUniqueId\n"
"float64 dTimestamp\n"
"bool mbAck\n"
"\n"
"#Grid (to speed up feature matching)\n"
"    int16 mnGridCols\n"
"    int16 mnGridRows\n"
"    float32 mfGridElementWidthInv\n"
"    float32 mfGridElementHeightInv\n"
"\n"
"#Calibration parameters\n"
"    float32 fx\n"
"    float32 fy\n"
"    float32 cx\n"
"    float32 cy\n"
"    float32 invfx\n"
"    float32 invfy\n"
"\n"
"#Number of KeyPoints\n"
"    int16 N\n"
"\n"
"#KeyPoints, stereo coordinate and descriptors (all associated by an index)\n"
"    CvKeyPoint[] mvKeysUn\n"
"    Descriptor[] mDescriptors\n"
"\n"
"#Pose relative to parent\n"
"    float32[16] mTcpred\n"
"    float32[16] mTcpar\n"
"\n"
"    bool mbPoseChanged\n"
"\n"
"    bool mbServerBA\n"
"\n"
"    float32[16] mT_SC\n"
"\n"
"#Scale\n"
"    int8 mnScaleLevels\n"
"    float32 mfScaleFactor\n"
"    float32 mfLogScaleFactor\n"
"    float32[8] mvScaleFactors\n"
"    float32[8] mvLevelSigma2\n"
"    float32[8] mvInvLevelSigma2\n"
"\n"
"#Image bounds and calibration\n"
"    int16 mnMinX\n"
"    int16 mnMinY\n"
"    int16 mnMaxX\n"
"    int16 mnMaxY\n"
"    float32[9] mK\n"
"\n"
"#MapPoints associated to keypoints\n"
"    uint32[] mvpMapPoints_Ids\n"
"    uint8[] mvpMapPoints_ClientIds\n"
"    uint16[] mvpMapPoints_VectId\n"
"\n"
"#Related KFs\n"
"    uint16 mpPred_KfId\n"
"    uint8 mpPred_KfClientId\n"
"    uint16 mpPar_KfId\n"
"    uint8 mpPar_KfClientId\n"
"\n"
"#Bad flags\n"
"    bool mbBad\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/CvKeyPoint\n"
"float32 fPoint2f_x\n"
"float32 fPoint2f_y\n"
"#float32 size\n"
"uint8 size\n"
"float32 angle\n"
"#float32 response\n"
"uint8 response\n"
"int8 octave\n"
"#int8 class_id\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/Descriptor\n"
"uint8[32] mDescriptor\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/KFred\n"
"uint16 mnId # unique KF id\n"
"uint8 mClientId # client id\n"
"uint32 mUniqueId\n"
"bool mbAck\n"
"\n"
"#Poses\n"
"    float32[16] mTcpred\n"
"    float32[16] mTcpar\n"
"\n"
"    uint16 mpPred_KfId\n"
"    uint8 mpPred_KfClientId\n"
"\n"
"    uint16 mpPar_KfId\n"
"    uint8 mpPar_KfClientId\n"
"\n"
"    bool mbServerBA\n"
"\n"
"#Bad flags\n"
"    bool mbBad\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/MP\n"
"bool bSentOnce\n"
"\n"
"uint32 mnId # unique MP id\n"
"uint8 mClientId # client id\n"
"uint32 mUniqueId\n"
"int16 mnFirstKFid\n"
"uint8 mnFirstKfClientId\n"
"bool mbAck\n"
"\n"
"#Position in absolute coordinates\n"
"     float32[3] mPosPred\n"
"     float32[3] mPosPar\n"
"     bool mbPoseChanged\n"
"\n"
"     bool mbServerBA\n"
"\n"
"#Keyframes observing the point and associated index in keyframe\n"
"     uint16[] mObservations_KFIDs\n"
"     uint8[] mObservations_KFClientIDs\n"
"     uint16[] mObservations_n\n"
"\n"
"#Mean viewing direction\n"
"     float32[3] mNormalVector\n"
"     bool mbNormalAndDepthChanged\n"
"\n"
"#Best descriptor to fast matching\n"
"     uint8[32] mDescriptor\n"
"\n"
"#Reference KeyFrame\n"
"     uint16 mpPredKFId\n"
"     uint8 mpPredKFClientId\n"
"     uint16 mpParKFId\n"
"     uint8 mpParKFClientId\n"
"\n"
"#Bad flag\n"
"     bool mbBad\n"
"\n"
"#Scale invariance distances\n"
"     float32 mfMinDistance\n"
"     float32 mfMaxDistance\n"
"\n"
"#Visualization\n"
"     bool mbMultiUse\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/MPred\n"
"uint32 mnId # unique MP id\n"
"uint8 mClientId # client id\n"
"uint32 mUniqueId\n"
"bool mbAck\n"
"\n"
"#Position in absolute coordinates\n"
"     float32[3] mPosPred\n"
"     float32[3] mPosPar\n"
"\n"
"     bool mbNormalAndDepthChanged\n"
"\n"
"    bool mbServerBA\n"
"\n"
"#Reference KeyFrame\n"
"     uint16 mpPredKFId\n"
"     uint8 mpPredKFClientId\n"
"     uint16 mpParKFId\n"
"     uint8 mpParKFClientId\n"
"\n"
"#Bad flag\n"
"     bool mbBad\n"
"\n"
"#Visualization\n"
"     bool mbMultiUse\n"
;
  }

  static const char* value(const ::ccmslam_msgs::Map_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ccmslam_msgs::Map_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.mMsgId);
      stream.next(m.Keyframes);
      stream.next(m.KFUpdates);
      stream.next(m.MapPoints);
      stream.next(m.MPUpdates);
      stream.next(m.vAckKFs);
      stream.next(m.vAckMPs);
      stream.next(m.WeakAckKF);
      stream.next(m.WeakAckMP);
      stream.next(m.ClosestKf_Id);
      stream.next(m.ClosestKf_ClientId);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Map_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ccmslam_msgs::Map_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ccmslam_msgs::Map_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "mMsgId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mMsgId);
    s << indent << "Keyframes[]" << std::endl;
    for (size_t i = 0; i < v.Keyframes.size(); ++i)
    {
      s << indent << "  Keyframes[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::KF_<ContainerAllocator> >::stream(s, indent + "    ", v.Keyframes[i]);
    }
    s << indent << "KFUpdates[]" << std::endl;
    for (size_t i = 0; i < v.KFUpdates.size(); ++i)
    {
      s << indent << "  KFUpdates[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::KFred_<ContainerAllocator> >::stream(s, indent + "    ", v.KFUpdates[i]);
    }
    s << indent << "MapPoints[]" << std::endl;
    for (size_t i = 0; i < v.MapPoints.size(); ++i)
    {
      s << indent << "  MapPoints[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::MP_<ContainerAllocator> >::stream(s, indent + "    ", v.MapPoints[i]);
    }
    s << indent << "MPUpdates[]" << std::endl;
    for (size_t i = 0; i < v.MPUpdates.size(); ++i)
    {
      s << indent << "  MPUpdates[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::MPred_<ContainerAllocator> >::stream(s, indent + "    ", v.MPUpdates[i]);
    }
    s << indent << "vAckKFs[]" << std::endl;
    for (size_t i = 0; i < v.vAckKFs.size(); ++i)
    {
      s << indent << "  vAckKFs[" << i << "]: ";
      Printer<uint16_t>::stream(s, indent + "  ", v.vAckKFs[i]);
    }
    s << indent << "vAckMPs[]" << std::endl;
    for (size_t i = 0; i < v.vAckMPs.size(); ++i)
    {
      s << indent << "  vAckMPs[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.vAckMPs[i]);
    }
    s << indent << "WeakAckKF: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.WeakAckKF);
    s << indent << "WeakAckMP: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.WeakAckMP);
    s << indent << "ClosestKf_Id: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.ClosestKf_Id);
    s << indent << "ClosestKf_ClientId: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ClosestKf_ClientId);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CCMSLAM_MSGS_MESSAGE_MAP_H
