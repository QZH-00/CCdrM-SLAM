// Generated by gencpp from file ccmslam_msgs/KF.msg
// DO NOT EDIT!


#ifndef CCMSLAM_MSGS_MESSAGE_KF_H
#define CCMSLAM_MSGS_MESSAGE_KF_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <ccmslam_msgs/CvKeyPoint.h>
#include <ccmslam_msgs/Descriptor.h>

namespace ccmslam_msgs
{
template <class ContainerAllocator>
struct KF_
{
  typedef KF_<ContainerAllocator> Type;

  KF_()
    : bSentOnce(false)
    , mnId(0)
    , mClientId(0)
    , mUniqueId(0)
    , dTimestamp(0.0)
    , mbAck(false)
    , mnGridCols(0)
    , mnGridRows(0)
    , mfGridElementWidthInv(0.0)
    , mfGridElementHeightInv(0.0)
    , fx(0.0)
    , fy(0.0)
    , cx(0.0)
    , cy(0.0)
    , invfx(0.0)
    , invfy(0.0)
    , N(0)
    , mvKeysUn()
    , mDescriptors()
    , mTcpred()
    , mTcpar()
    , mbPoseChanged(false)
    , mbServerBA(false)
    , mT_SC()
    , mnScaleLevels(0)
    , mfScaleFactor(0.0)
    , mfLogScaleFactor(0.0)
    , mvScaleFactors()
    , mvLevelSigma2()
    , mvInvLevelSigma2()
    , mnMinX(0)
    , mnMinY(0)
    , mnMaxX(0)
    , mnMaxY(0)
    , mK()
    , mvpMapPoints_Ids()
    , mvpMapPoints_ClientIds()
    , mvpMapPoints_VectId()
    , mpPred_KfId(0)
    , mpPred_KfClientId(0)
    , mpPar_KfId(0)
    , mpPar_KfClientId(0)
    , mbBad(false)  {
      mTcpred.assign(0.0);

      mTcpar.assign(0.0);

      mT_SC.assign(0.0);

      mvScaleFactors.assign(0.0);

      mvLevelSigma2.assign(0.0);

      mvInvLevelSigma2.assign(0.0);

      mK.assign(0.0);
  }
  KF_(const ContainerAllocator& _alloc)
    : bSentOnce(false)
    , mnId(0)
    , mClientId(0)
    , mUniqueId(0)
    , dTimestamp(0.0)
    , mbAck(false)
    , mnGridCols(0)
    , mnGridRows(0)
    , mfGridElementWidthInv(0.0)
    , mfGridElementHeightInv(0.0)
    , fx(0.0)
    , fy(0.0)
    , cx(0.0)
    , cy(0.0)
    , invfx(0.0)
    , invfy(0.0)
    , N(0)
    , mvKeysUn(_alloc)
    , mDescriptors(_alloc)
    , mTcpred()
    , mTcpar()
    , mbPoseChanged(false)
    , mbServerBA(false)
    , mT_SC()
    , mnScaleLevels(0)
    , mfScaleFactor(0.0)
    , mfLogScaleFactor(0.0)
    , mvScaleFactors()
    , mvLevelSigma2()
    , mvInvLevelSigma2()
    , mnMinX(0)
    , mnMinY(0)
    , mnMaxX(0)
    , mnMaxY(0)
    , mK()
    , mvpMapPoints_Ids(_alloc)
    , mvpMapPoints_ClientIds(_alloc)
    , mvpMapPoints_VectId(_alloc)
    , mpPred_KfId(0)
    , mpPred_KfClientId(0)
    , mpPar_KfId(0)
    , mpPar_KfClientId(0)
    , mbBad(false)  {
  (void)_alloc;
      mTcpred.assign(0.0);

      mTcpar.assign(0.0);

      mT_SC.assign(0.0);

      mvScaleFactors.assign(0.0);

      mvLevelSigma2.assign(0.0);

      mvInvLevelSigma2.assign(0.0);

      mK.assign(0.0);
  }



   typedef uint8_t _bSentOnce_type;
  _bSentOnce_type bSentOnce;

   typedef uint16_t _mnId_type;
  _mnId_type mnId;

   typedef uint8_t _mClientId_type;
  _mClientId_type mClientId;

   typedef uint32_t _mUniqueId_type;
  _mUniqueId_type mUniqueId;

   typedef double _dTimestamp_type;
  _dTimestamp_type dTimestamp;

   typedef uint8_t _mbAck_type;
  _mbAck_type mbAck;

   typedef int16_t _mnGridCols_type;
  _mnGridCols_type mnGridCols;

   typedef int16_t _mnGridRows_type;
  _mnGridRows_type mnGridRows;

   typedef float _mfGridElementWidthInv_type;
  _mfGridElementWidthInv_type mfGridElementWidthInv;

   typedef float _mfGridElementHeightInv_type;
  _mfGridElementHeightInv_type mfGridElementHeightInv;

   typedef float _fx_type;
  _fx_type fx;

   typedef float _fy_type;
  _fy_type fy;

   typedef float _cx_type;
  _cx_type cx;

   typedef float _cy_type;
  _cy_type cy;

   typedef float _invfx_type;
  _invfx_type invfx;

   typedef float _invfy_type;
  _invfy_type invfy;

   typedef int16_t _N_type;
  _N_type N;

   typedef std::vector< ::ccmslam_msgs::CvKeyPoint_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::CvKeyPoint_<ContainerAllocator> >> _mvKeysUn_type;
  _mvKeysUn_type mvKeysUn;

   typedef std::vector< ::ccmslam_msgs::Descriptor_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::ccmslam_msgs::Descriptor_<ContainerAllocator> >> _mDescriptors_type;
  _mDescriptors_type mDescriptors;

   typedef boost::array<float, 16>  _mTcpred_type;
  _mTcpred_type mTcpred;

   typedef boost::array<float, 16>  _mTcpar_type;
  _mTcpar_type mTcpar;

   typedef uint8_t _mbPoseChanged_type;
  _mbPoseChanged_type mbPoseChanged;

   typedef uint8_t _mbServerBA_type;
  _mbServerBA_type mbServerBA;

   typedef boost::array<float, 16>  _mT_SC_type;
  _mT_SC_type mT_SC;

   typedef int8_t _mnScaleLevels_type;
  _mnScaleLevels_type mnScaleLevels;

   typedef float _mfScaleFactor_type;
  _mfScaleFactor_type mfScaleFactor;

   typedef float _mfLogScaleFactor_type;
  _mfLogScaleFactor_type mfLogScaleFactor;

   typedef boost::array<float, 8>  _mvScaleFactors_type;
  _mvScaleFactors_type mvScaleFactors;

   typedef boost::array<float, 8>  _mvLevelSigma2_type;
  _mvLevelSigma2_type mvLevelSigma2;

   typedef boost::array<float, 8>  _mvInvLevelSigma2_type;
  _mvInvLevelSigma2_type mvInvLevelSigma2;

   typedef int16_t _mnMinX_type;
  _mnMinX_type mnMinX;

   typedef int16_t _mnMinY_type;
  _mnMinY_type mnMinY;

   typedef int16_t _mnMaxX_type;
  _mnMaxX_type mnMaxX;

   typedef int16_t _mnMaxY_type;
  _mnMaxY_type mnMaxY;

   typedef boost::array<float, 9>  _mK_type;
  _mK_type mK;

   typedef std::vector<uint32_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint32_t>> _mvpMapPoints_Ids_type;
  _mvpMapPoints_Ids_type mvpMapPoints_Ids;

   typedef std::vector<uint8_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint8_t>> _mvpMapPoints_ClientIds_type;
  _mvpMapPoints_ClientIds_type mvpMapPoints_ClientIds;

   typedef std::vector<uint16_t, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<uint16_t>> _mvpMapPoints_VectId_type;
  _mvpMapPoints_VectId_type mvpMapPoints_VectId;

   typedef uint16_t _mpPred_KfId_type;
  _mpPred_KfId_type mpPred_KfId;

   typedef uint8_t _mpPred_KfClientId_type;
  _mpPred_KfClientId_type mpPred_KfClientId;

   typedef uint16_t _mpPar_KfId_type;
  _mpPar_KfId_type mpPar_KfId;

   typedef uint8_t _mpPar_KfClientId_type;
  _mpPar_KfClientId_type mpPar_KfClientId;

   typedef uint8_t _mbBad_type;
  _mbBad_type mbBad;





  typedef boost::shared_ptr< ::ccmslam_msgs::KF_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ccmslam_msgs::KF_<ContainerAllocator> const> ConstPtr;

}; // struct KF_

typedef ::ccmslam_msgs::KF_<std::allocator<void> > KF;

typedef boost::shared_ptr< ::ccmslam_msgs::KF > KFPtr;
typedef boost::shared_ptr< ::ccmslam_msgs::KF const> KFConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ccmslam_msgs::KF_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ccmslam_msgs::KF_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ccmslam_msgs::KF_<ContainerAllocator1> & lhs, const ::ccmslam_msgs::KF_<ContainerAllocator2> & rhs)
{
  return lhs.bSentOnce == rhs.bSentOnce &&
    lhs.mnId == rhs.mnId &&
    lhs.mClientId == rhs.mClientId &&
    lhs.mUniqueId == rhs.mUniqueId &&
    lhs.dTimestamp == rhs.dTimestamp &&
    lhs.mbAck == rhs.mbAck &&
    lhs.mnGridCols == rhs.mnGridCols &&
    lhs.mnGridRows == rhs.mnGridRows &&
    lhs.mfGridElementWidthInv == rhs.mfGridElementWidthInv &&
    lhs.mfGridElementHeightInv == rhs.mfGridElementHeightInv &&
    lhs.fx == rhs.fx &&
    lhs.fy == rhs.fy &&
    lhs.cx == rhs.cx &&
    lhs.cy == rhs.cy &&
    lhs.invfx == rhs.invfx &&
    lhs.invfy == rhs.invfy &&
    lhs.N == rhs.N &&
    lhs.mvKeysUn == rhs.mvKeysUn &&
    lhs.mDescriptors == rhs.mDescriptors &&
    lhs.mTcpred == rhs.mTcpred &&
    lhs.mTcpar == rhs.mTcpar &&
    lhs.mbPoseChanged == rhs.mbPoseChanged &&
    lhs.mbServerBA == rhs.mbServerBA &&
    lhs.mT_SC == rhs.mT_SC &&
    lhs.mnScaleLevels == rhs.mnScaleLevels &&
    lhs.mfScaleFactor == rhs.mfScaleFactor &&
    lhs.mfLogScaleFactor == rhs.mfLogScaleFactor &&
    lhs.mvScaleFactors == rhs.mvScaleFactors &&
    lhs.mvLevelSigma2 == rhs.mvLevelSigma2 &&
    lhs.mvInvLevelSigma2 == rhs.mvInvLevelSigma2 &&
    lhs.mnMinX == rhs.mnMinX &&
    lhs.mnMinY == rhs.mnMinY &&
    lhs.mnMaxX == rhs.mnMaxX &&
    lhs.mnMaxY == rhs.mnMaxY &&
    lhs.mK == rhs.mK &&
    lhs.mvpMapPoints_Ids == rhs.mvpMapPoints_Ids &&
    lhs.mvpMapPoints_ClientIds == rhs.mvpMapPoints_ClientIds &&
    lhs.mvpMapPoints_VectId == rhs.mvpMapPoints_VectId &&
    lhs.mpPred_KfId == rhs.mpPred_KfId &&
    lhs.mpPred_KfClientId == rhs.mpPred_KfClientId &&
    lhs.mpPar_KfId == rhs.mpPar_KfId &&
    lhs.mpPar_KfClientId == rhs.mpPar_KfClientId &&
    lhs.mbBad == rhs.mbBad;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ccmslam_msgs::KF_<ContainerAllocator1> & lhs, const ::ccmslam_msgs::KF_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ccmslam_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::ccmslam_msgs::KF_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ccmslam_msgs::KF_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ccmslam_msgs::KF_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ccmslam_msgs::KF_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ccmslam_msgs::KF_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ccmslam_msgs::KF_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ccmslam_msgs::KF_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b4bea7926c2bbbbd22b81573a50253bf";
  }

  static const char* value(const ::ccmslam_msgs::KF_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb4bea7926c2bbbbdULL;
  static const uint64_t static_value2 = 0x22b81573a50253bfULL;
};

template<class ContainerAllocator>
struct DataType< ::ccmslam_msgs::KF_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ccmslam_msgs/KF";
  }

  static const char* value(const ::ccmslam_msgs::KF_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ccmslam_msgs::KF_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool bSentOnce\n"
"\n"
"uint16 mnId # unique KF id\n"
"uint8 mClientId # client id\n"
"uint32 mUniqueId\n"
"float64 dTimestamp\n"
"bool mbAck\n"
"\n"
"#Grid (to speed up feature matching)\n"
"    int16 mnGridCols\n"
"    int16 mnGridRows\n"
"    float32 mfGridElementWidthInv\n"
"    float32 mfGridElementHeightInv\n"
"\n"
"#Calibration parameters\n"
"    float32 fx\n"
"    float32 fy\n"
"    float32 cx\n"
"    float32 cy\n"
"    float32 invfx\n"
"    float32 invfy\n"
"\n"
"#Number of KeyPoints\n"
"    int16 N\n"
"\n"
"#KeyPoints, stereo coordinate and descriptors (all associated by an index)\n"
"    CvKeyPoint[] mvKeysUn\n"
"    Descriptor[] mDescriptors\n"
"\n"
"#Pose relative to parent\n"
"    float32[16] mTcpred\n"
"    float32[16] mTcpar\n"
"\n"
"    bool mbPoseChanged\n"
"\n"
"    bool mbServerBA\n"
"\n"
"    float32[16] mT_SC\n"
"\n"
"#Scale\n"
"    int8 mnScaleLevels\n"
"    float32 mfScaleFactor\n"
"    float32 mfLogScaleFactor\n"
"    float32[8] mvScaleFactors\n"
"    float32[8] mvLevelSigma2\n"
"    float32[8] mvInvLevelSigma2\n"
"\n"
"#Image bounds and calibration\n"
"    int16 mnMinX\n"
"    int16 mnMinY\n"
"    int16 mnMaxX\n"
"    int16 mnMaxY\n"
"    float32[9] mK\n"
"\n"
"#MapPoints associated to keypoints\n"
"    uint32[] mvpMapPoints_Ids\n"
"    uint8[] mvpMapPoints_ClientIds\n"
"    uint16[] mvpMapPoints_VectId\n"
"\n"
"#Related KFs\n"
"    uint16 mpPred_KfId\n"
"    uint8 mpPred_KfClientId\n"
"    uint16 mpPar_KfId\n"
"    uint8 mpPar_KfClientId\n"
"\n"
"#Bad flags\n"
"    bool mbBad\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/CvKeyPoint\n"
"float32 fPoint2f_x\n"
"float32 fPoint2f_y\n"
"#float32 size\n"
"uint8 size\n"
"float32 angle\n"
"#float32 response\n"
"uint8 response\n"
"int8 octave\n"
"#int8 class_id\n"
"\n"
"================================================================================\n"
"MSG: ccmslam_msgs/Descriptor\n"
"uint8[32] mDescriptor\n"
;
  }

  static const char* value(const ::ccmslam_msgs::KF_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ccmslam_msgs::KF_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.bSentOnce);
      stream.next(m.mnId);
      stream.next(m.mClientId);
      stream.next(m.mUniqueId);
      stream.next(m.dTimestamp);
      stream.next(m.mbAck);
      stream.next(m.mnGridCols);
      stream.next(m.mnGridRows);
      stream.next(m.mfGridElementWidthInv);
      stream.next(m.mfGridElementHeightInv);
      stream.next(m.fx);
      stream.next(m.fy);
      stream.next(m.cx);
      stream.next(m.cy);
      stream.next(m.invfx);
      stream.next(m.invfy);
      stream.next(m.N);
      stream.next(m.mvKeysUn);
      stream.next(m.mDescriptors);
      stream.next(m.mTcpred);
      stream.next(m.mTcpar);
      stream.next(m.mbPoseChanged);
      stream.next(m.mbServerBA);
      stream.next(m.mT_SC);
      stream.next(m.mnScaleLevels);
      stream.next(m.mfScaleFactor);
      stream.next(m.mfLogScaleFactor);
      stream.next(m.mvScaleFactors);
      stream.next(m.mvLevelSigma2);
      stream.next(m.mvInvLevelSigma2);
      stream.next(m.mnMinX);
      stream.next(m.mnMinY);
      stream.next(m.mnMaxX);
      stream.next(m.mnMaxY);
      stream.next(m.mK);
      stream.next(m.mvpMapPoints_Ids);
      stream.next(m.mvpMapPoints_ClientIds);
      stream.next(m.mvpMapPoints_VectId);
      stream.next(m.mpPred_KfId);
      stream.next(m.mpPred_KfClientId);
      stream.next(m.mpPar_KfId);
      stream.next(m.mpPar_KfClientId);
      stream.next(m.mbBad);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct KF_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ccmslam_msgs::KF_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ccmslam_msgs::KF_<ContainerAllocator>& v)
  {
    s << indent << "bSentOnce: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bSentOnce);
    s << indent << "mnId: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mnId);
    s << indent << "mClientId: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mClientId);
    s << indent << "mUniqueId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mUniqueId);
    s << indent << "dTimestamp: ";
    Printer<double>::stream(s, indent + "  ", v.dTimestamp);
    s << indent << "mbAck: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mbAck);
    s << indent << "mnGridCols: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnGridCols);
    s << indent << "mnGridRows: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnGridRows);
    s << indent << "mfGridElementWidthInv: ";
    Printer<float>::stream(s, indent + "  ", v.mfGridElementWidthInv);
    s << indent << "mfGridElementHeightInv: ";
    Printer<float>::stream(s, indent + "  ", v.mfGridElementHeightInv);
    s << indent << "fx: ";
    Printer<float>::stream(s, indent + "  ", v.fx);
    s << indent << "fy: ";
    Printer<float>::stream(s, indent + "  ", v.fy);
    s << indent << "cx: ";
    Printer<float>::stream(s, indent + "  ", v.cx);
    s << indent << "cy: ";
    Printer<float>::stream(s, indent + "  ", v.cy);
    s << indent << "invfx: ";
    Printer<float>::stream(s, indent + "  ", v.invfx);
    s << indent << "invfy: ";
    Printer<float>::stream(s, indent + "  ", v.invfy);
    s << indent << "N: ";
    Printer<int16_t>::stream(s, indent + "  ", v.N);
    s << indent << "mvKeysUn[]" << std::endl;
    for (size_t i = 0; i < v.mvKeysUn.size(); ++i)
    {
      s << indent << "  mvKeysUn[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::CvKeyPoint_<ContainerAllocator> >::stream(s, indent + "    ", v.mvKeysUn[i]);
    }
    s << indent << "mDescriptors[]" << std::endl;
    for (size_t i = 0; i < v.mDescriptors.size(); ++i)
    {
      s << indent << "  mDescriptors[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::ccmslam_msgs::Descriptor_<ContainerAllocator> >::stream(s, indent + "    ", v.mDescriptors[i]);
    }
    s << indent << "mTcpred[]" << std::endl;
    for (size_t i = 0; i < v.mTcpred.size(); ++i)
    {
      s << indent << "  mTcpred[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mTcpred[i]);
    }
    s << indent << "mTcpar[]" << std::endl;
    for (size_t i = 0; i < v.mTcpar.size(); ++i)
    {
      s << indent << "  mTcpar[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mTcpar[i]);
    }
    s << indent << "mbPoseChanged: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mbPoseChanged);
    s << indent << "mbServerBA: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mbServerBA);
    s << indent << "mT_SC[]" << std::endl;
    for (size_t i = 0; i < v.mT_SC.size(); ++i)
    {
      s << indent << "  mT_SC[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mT_SC[i]);
    }
    s << indent << "mnScaleLevels: ";
    Printer<int8_t>::stream(s, indent + "  ", v.mnScaleLevels);
    s << indent << "mfScaleFactor: ";
    Printer<float>::stream(s, indent + "  ", v.mfScaleFactor);
    s << indent << "mfLogScaleFactor: ";
    Printer<float>::stream(s, indent + "  ", v.mfLogScaleFactor);
    s << indent << "mvScaleFactors[]" << std::endl;
    for (size_t i = 0; i < v.mvScaleFactors.size(); ++i)
    {
      s << indent << "  mvScaleFactors[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mvScaleFactors[i]);
    }
    s << indent << "mvLevelSigma2[]" << std::endl;
    for (size_t i = 0; i < v.mvLevelSigma2.size(); ++i)
    {
      s << indent << "  mvLevelSigma2[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mvLevelSigma2[i]);
    }
    s << indent << "mvInvLevelSigma2[]" << std::endl;
    for (size_t i = 0; i < v.mvInvLevelSigma2.size(); ++i)
    {
      s << indent << "  mvInvLevelSigma2[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mvInvLevelSigma2[i]);
    }
    s << indent << "mnMinX: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnMinX);
    s << indent << "mnMinY: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnMinY);
    s << indent << "mnMaxX: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnMaxX);
    s << indent << "mnMaxY: ";
    Printer<int16_t>::stream(s, indent + "  ", v.mnMaxY);
    s << indent << "mK[]" << std::endl;
    for (size_t i = 0; i < v.mK.size(); ++i)
    {
      s << indent << "  mK[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.mK[i]);
    }
    s << indent << "mvpMapPoints_Ids[]" << std::endl;
    for (size_t i = 0; i < v.mvpMapPoints_Ids.size(); ++i)
    {
      s << indent << "  mvpMapPoints_Ids[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.mvpMapPoints_Ids[i]);
    }
    s << indent << "mvpMapPoints_ClientIds[]" << std::endl;
    for (size_t i = 0; i < v.mvpMapPoints_ClientIds.size(); ++i)
    {
      s << indent << "  mvpMapPoints_ClientIds[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.mvpMapPoints_ClientIds[i]);
    }
    s << indent << "mvpMapPoints_VectId[]" << std::endl;
    for (size_t i = 0; i < v.mvpMapPoints_VectId.size(); ++i)
    {
      s << indent << "  mvpMapPoints_VectId[" << i << "]: ";
      Printer<uint16_t>::stream(s, indent + "  ", v.mvpMapPoints_VectId[i]);
    }
    s << indent << "mpPred_KfId: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mpPred_KfId);
    s << indent << "mpPred_KfClientId: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mpPred_KfClientId);
    s << indent << "mpPar_KfId: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.mpPar_KfId);
    s << indent << "mpPar_KfClientId: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mpPar_KfClientId);
    s << indent << "mbBad: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mbBad);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CCMSLAM_MSGS_MESSAGE_KF_H
