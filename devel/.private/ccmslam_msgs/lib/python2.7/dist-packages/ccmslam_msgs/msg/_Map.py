# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ccmslam_msgs/Map.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import ccmslam_msgs.msg
import std_msgs.msg

class Map(genpy.Message):
  _md5sum = "b75f9043a42e539da365451900525c5c"
  _type = "ccmslam_msgs/Map"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header
uint32 mMsgId

KF[] Keyframes
KFred[] KFUpdates
MP[] MapPoints
MPred[] MPUpdates

#bool bAck
#uint32 Ack #should not be necessary any more
uint16[] vAckKFs
uint32[] vAckMPs
uint16 WeakAckKF
uint32 WeakAckMP

uint16 ClosestKf_Id
uint8 ClosestKf_ClientId

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: ccmslam_msgs/KF
bool bSentOnce

uint16 mnId # unique KF id
uint8 mClientId # client id
uint32 mUniqueId
float64 dTimestamp
bool mbAck

#Grid (to speed up feature matching)
    int16 mnGridCols
    int16 mnGridRows
    float32 mfGridElementWidthInv
    float32 mfGridElementHeightInv

#Calibration parameters
    float32 fx
    float32 fy
    float32 cx
    float32 cy
    float32 invfx
    float32 invfy

#Number of KeyPoints
    int16 N

#KeyPoints, stereo coordinate and descriptors (all associated by an index)
    CvKeyPoint[] mvKeysUn
    Descriptor[] mDescriptors

#Pose relative to parent
    float32[16] mTcpred
    float32[16] mTcpar

    bool mbPoseChanged

    bool mbServerBA

    float32[16] mT_SC

#Scale
    int8 mnScaleLevels
    float32 mfScaleFactor
    float32 mfLogScaleFactor
    float32[8] mvScaleFactors
    float32[8] mvLevelSigma2
    float32[8] mvInvLevelSigma2

#Image bounds and calibration
    int16 mnMinX
    int16 mnMinY
    int16 mnMaxX
    int16 mnMaxY
    float32[9] mK

#MapPoints associated to keypoints
    uint32[] mvpMapPoints_Ids
    uint8[] mvpMapPoints_ClientIds
    uint16[] mvpMapPoints_VectId

#Related KFs
    uint16 mpPred_KfId
    uint8 mpPred_KfClientId
    uint16 mpPar_KfId
    uint8 mpPar_KfClientId

#Bad flags
    bool mbBad

================================================================================
MSG: ccmslam_msgs/CvKeyPoint
float32 fPoint2f_x
float32 fPoint2f_y
#float32 size
uint8 size
float32 angle
#float32 response
uint8 response
int8 octave
#int8 class_id

================================================================================
MSG: ccmslam_msgs/Descriptor
uint8[32] mDescriptor

================================================================================
MSG: ccmslam_msgs/KFred
uint16 mnId # unique KF id
uint8 mClientId # client id
uint32 mUniqueId
bool mbAck

#Poses
    float32[16] mTcpred
    float32[16] mTcpar

    uint16 mpPred_KfId
    uint8 mpPred_KfClientId

    uint16 mpPar_KfId
    uint8 mpPar_KfClientId

    bool mbServerBA

#Bad flags
    bool mbBad

================================================================================
MSG: ccmslam_msgs/MP
bool bSentOnce

uint32 mnId # unique MP id
uint8 mClientId # client id
uint32 mUniqueId
int16 mnFirstKFid
uint8 mnFirstKfClientId
bool mbAck

#Position in absolute coordinates
     float32[3] mPosPred
     float32[3] mPosPar
     bool mbPoseChanged

     bool mbServerBA

#Keyframes observing the point and associated index in keyframe
     uint16[] mObservations_KFIDs
     uint8[] mObservations_KFClientIDs
     uint16[] mObservations_n

#Mean viewing direction
     float32[3] mNormalVector
     bool mbNormalAndDepthChanged

#Best descriptor to fast matching
     uint8[32] mDescriptor

#Reference KeyFrame
     uint16 mpPredKFId
     uint8 mpPredKFClientId
     uint16 mpParKFId
     uint8 mpParKFClientId

#Bad flag
     bool mbBad

#Scale invariance distances
     float32 mfMinDistance
     float32 mfMaxDistance

#Visualization
     bool mbMultiUse

================================================================================
MSG: ccmslam_msgs/MPred
uint32 mnId # unique MP id
uint8 mClientId # client id
uint32 mUniqueId
bool mbAck

#Position in absolute coordinates
     float32[3] mPosPred
     float32[3] mPosPar

     bool mbNormalAndDepthChanged

    bool mbServerBA

#Reference KeyFrame
     uint16 mpPredKFId
     uint8 mpPredKFClientId
     uint16 mpParKFId
     uint8 mpParKFClientId

#Bad flag
     bool mbBad

#Visualization
     bool mbMultiUse
"""
  __slots__ = ['header','mMsgId','Keyframes','KFUpdates','MapPoints','MPUpdates','vAckKFs','vAckMPs','WeakAckKF','WeakAckMP','ClosestKf_Id','ClosestKf_ClientId']
  _slot_types = ['std_msgs/Header','uint32','ccmslam_msgs/KF[]','ccmslam_msgs/KFred[]','ccmslam_msgs/MP[]','ccmslam_msgs/MPred[]','uint16[]','uint32[]','uint16','uint32','uint16','uint8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,mMsgId,Keyframes,KFUpdates,MapPoints,MPUpdates,vAckKFs,vAckMPs,WeakAckKF,WeakAckMP,ClosestKf_Id,ClosestKf_ClientId

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Map, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.mMsgId is None:
        self.mMsgId = 0
      if self.Keyframes is None:
        self.Keyframes = []
      if self.KFUpdates is None:
        self.KFUpdates = []
      if self.MapPoints is None:
        self.MapPoints = []
      if self.MPUpdates is None:
        self.MPUpdates = []
      if self.vAckKFs is None:
        self.vAckKFs = []
      if self.vAckMPs is None:
        self.vAckMPs = []
      if self.WeakAckKF is None:
        self.WeakAckKF = 0
      if self.WeakAckMP is None:
        self.WeakAckMP = 0
      if self.ClosestKf_Id is None:
        self.ClosestKf_Id = 0
      if self.ClosestKf_ClientId is None:
        self.ClosestKf_ClientId = 0
    else:
      self.header = std_msgs.msg.Header()
      self.mMsgId = 0
      self.Keyframes = []
      self.KFUpdates = []
      self.MapPoints = []
      self.MPUpdates = []
      self.vAckKFs = []
      self.vAckMPs = []
      self.WeakAckKF = 0
      self.WeakAckMP = 0
      self.ClosestKf_Id = 0
      self.ClosestKf_ClientId = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mMsgId
      buff.write(_get_struct_I().pack(_x))
      length = len(self.Keyframes)
      buff.write(_struct_I.pack(length))
      for val1 in self.Keyframes:
        _x = val1
        buff.write(_get_struct_BHBIdB2h8fh().pack(_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.dTimestamp, _x.mbAck, _x.mnGridCols, _x.mnGridRows, _x.mfGridElementWidthInv, _x.mfGridElementHeightInv, _x.fx, _x.fy, _x.cx, _x.cy, _x.invfx, _x.invfy, _x.N))
        length = len(val1.mvKeysUn)
        buff.write(_struct_I.pack(length))
        for val2 in val1.mvKeysUn:
          _x = val2
          buff.write(_get_struct_2fBfBb().pack(_x.fPoint2f_x, _x.fPoint2f_y, _x.size, _x.angle, _x.response, _x.octave))
        length = len(val1.mDescriptors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.mDescriptors:
          _x = val2.mDescriptor
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(_get_struct_32B().pack(*_x))
          else:
            buff.write(_get_struct_32s().pack(_x))
        buff.write(_get_struct_16f().pack(*val1.mTcpred))
        buff.write(_get_struct_16f().pack(*val1.mTcpar))
        _x = val1
        buff.write(_get_struct_2B().pack(_x.mbPoseChanged, _x.mbServerBA))
        buff.write(_get_struct_16f().pack(*val1.mT_SC))
        _x = val1
        buff.write(_get_struct_b2f().pack(_x.mnScaleLevels, _x.mfScaleFactor, _x.mfLogScaleFactor))
        buff.write(_get_struct_8f().pack(*val1.mvScaleFactors))
        buff.write(_get_struct_8f().pack(*val1.mvLevelSigma2))
        buff.write(_get_struct_8f().pack(*val1.mvInvLevelSigma2))
        _x = val1
        buff.write(_get_struct_4h().pack(_x.mnMinX, _x.mnMinY, _x.mnMaxX, _x.mnMaxY))
        buff.write(_get_struct_9f().pack(*val1.mK))
        length = len(val1.mvpMapPoints_Ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(struct.Struct(pattern).pack(*val1.mvpMapPoints_Ids))
        _x = val1.mvpMapPoints_ClientIds
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.mvpMapPoints_VectId)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(struct.Struct(pattern).pack(*val1.mvpMapPoints_VectId))
        _x = val1
        buff.write(_get_struct_HBH2B().pack(_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbBad))
      length = len(self.KFUpdates)
      buff.write(_struct_I.pack(length))
      for val1 in self.KFUpdates:
        _x = val1
        buff.write(_get_struct_HBIB().pack(_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck))
        buff.write(_get_struct_16f().pack(*val1.mTcpred))
        buff.write(_get_struct_16f().pack(*val1.mTcpar))
        _x = val1
        buff.write(_get_struct_HBH3B().pack(_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbServerBA, _x.mbBad))
      length = len(self.MapPoints)
      buff.write(_struct_I.pack(length))
      for val1 in self.MapPoints:
        _x = val1
        buff.write(_get_struct_BIBIh2B().pack(_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.mnFirstKFid, _x.mnFirstKfClientId, _x.mbAck))
        buff.write(_get_struct_3f().pack(*val1.mPosPred))
        buff.write(_get_struct_3f().pack(*val1.mPosPar))
        _x = val1
        buff.write(_get_struct_2B().pack(_x.mbPoseChanged, _x.mbServerBA))
        length = len(val1.mObservations_KFIDs)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(struct.Struct(pattern).pack(*val1.mObservations_KFIDs))
        _x = val1.mObservations_KFClientIDs
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.mObservations_n)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(struct.Struct(pattern).pack(*val1.mObservations_n))
        buff.write(_get_struct_3f().pack(*val1.mNormalVector))
        _x = val1.mbNormalAndDepthChanged
        buff.write(_get_struct_B().pack(_x))
        _x = val1.mDescriptor
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(_get_struct_32B().pack(*_x))
        else:
          buff.write(_get_struct_32s().pack(_x))
        _x = val1
        buff.write(_get_struct_HBH2B2fB().pack(_x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mfMinDistance, _x.mfMaxDistance, _x.mbMultiUse))
      length = len(self.MPUpdates)
      buff.write(_struct_I.pack(length))
      for val1 in self.MPUpdates:
        _x = val1
        buff.write(_get_struct_IBIB().pack(_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck))
        buff.write(_get_struct_3f().pack(*val1.mPosPred))
        buff.write(_get_struct_3f().pack(*val1.mPosPar))
        _x = val1
        buff.write(_get_struct_2BHBH3B().pack(_x.mbNormalAndDepthChanged, _x.mbServerBA, _x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mbMultiUse))
      length = len(self.vAckKFs)
      buff.write(_struct_I.pack(length))
      pattern = '<%sH'%length
      buff.write(struct.Struct(pattern).pack(*self.vAckKFs))
      length = len(self.vAckMPs)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(struct.Struct(pattern).pack(*self.vAckMPs))
      _x = self
      buff.write(_get_struct_HIHB().pack(_x.WeakAckKF, _x.WeakAckMP, _x.ClosestKf_Id, _x.ClosestKf_ClientId))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.Keyframes is None:
        self.Keyframes = None
      if self.KFUpdates is None:
        self.KFUpdates = None
      if self.MapPoints is None:
        self.MapPoints = None
      if self.MPUpdates is None:
        self.MPUpdates = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (self.mMsgId,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Keyframes = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.KF()
        _x = val1
        start = end
        end += 55
        (_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.dTimestamp, _x.mbAck, _x.mnGridCols, _x.mnGridRows, _x.mfGridElementWidthInv, _x.mfGridElementHeightInv, _x.fx, _x.fy, _x.cx, _x.cy, _x.invfx, _x.invfy, _x.N,) = _get_struct_BHBIdB2h8fh().unpack(str[start:end])
        val1.bSentOnce = bool(val1.bSentOnce)
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.mvKeysUn = []
        for i in range(0, length):
          val2 = ccmslam_msgs.msg.CvKeyPoint()
          _x = val2
          start = end
          end += 15
          (_x.fPoint2f_x, _x.fPoint2f_y, _x.size, _x.angle, _x.response, _x.octave,) = _get_struct_2fBfBb().unpack(str[start:end])
          val1.mvKeysUn.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.mDescriptors = []
        for i in range(0, length):
          val2 = ccmslam_msgs.msg.Descriptor()
          start = end
          end += 32
          val2.mDescriptor = str[start:end]
          val1.mDescriptors.append(val2)
        start = end
        end += 64
        val1.mTcpred = _get_struct_16f().unpack(str[start:end])
        start = end
        end += 64
        val1.mTcpar = _get_struct_16f().unpack(str[start:end])
        _x = val1
        start = end
        end += 2
        (_x.mbPoseChanged, _x.mbServerBA,) = _get_struct_2B().unpack(str[start:end])
        val1.mbPoseChanged = bool(val1.mbPoseChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        start = end
        end += 64
        val1.mT_SC = _get_struct_16f().unpack(str[start:end])
        _x = val1
        start = end
        end += 9
        (_x.mnScaleLevels, _x.mfScaleFactor, _x.mfLogScaleFactor,) = _get_struct_b2f().unpack(str[start:end])
        start = end
        end += 32
        val1.mvScaleFactors = _get_struct_8f().unpack(str[start:end])
        start = end
        end += 32
        val1.mvLevelSigma2 = _get_struct_8f().unpack(str[start:end])
        start = end
        end += 32
        val1.mvInvLevelSigma2 = _get_struct_8f().unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.mnMinX, _x.mnMinY, _x.mnMaxX, _x.mnMaxY,) = _get_struct_4h().unpack(str[start:end])
        start = end
        end += 36
        val1.mK = _get_struct_9f().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mvpMapPoints_Ids = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mvpMapPoints_ClientIds = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mvpMapPoints_VectId = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 7
        (_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbBad,) = _get_struct_HBH2B().unpack(str[start:end])
        val1.mbBad = bool(val1.mbBad)
        self.Keyframes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.KFUpdates = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.KFred()
        _x = val1
        start = end
        end += 8
        (_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck,) = _get_struct_HBIB().unpack(str[start:end])
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 64
        val1.mTcpred = _get_struct_16f().unpack(str[start:end])
        start = end
        end += 64
        val1.mTcpar = _get_struct_16f().unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbServerBA, _x.mbBad,) = _get_struct_HBH3B().unpack(str[start:end])
        val1.mbServerBA = bool(val1.mbServerBA)
        val1.mbBad = bool(val1.mbBad)
        self.KFUpdates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.MapPoints = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.MP()
        _x = val1
        start = end
        end += 14
        (_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.mnFirstKFid, _x.mnFirstKfClientId, _x.mbAck,) = _get_struct_BIBIh2B().unpack(str[start:end])
        val1.bSentOnce = bool(val1.bSentOnce)
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 12
        val1.mPosPred = _get_struct_3f().unpack(str[start:end])
        start = end
        end += 12
        val1.mPosPar = _get_struct_3f().unpack(str[start:end])
        _x = val1
        start = end
        end += 2
        (_x.mbPoseChanged, _x.mbServerBA,) = _get_struct_2B().unpack(str[start:end])
        val1.mbPoseChanged = bool(val1.mbPoseChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mObservations_KFIDs = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mObservations_KFClientIDs = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mObservations_n = s.unpack(str[start:end])
        start = end
        end += 12
        val1.mNormalVector = _get_struct_3f().unpack(str[start:end])
        start = end
        end += 1
        (val1.mbNormalAndDepthChanged,) = _get_struct_B().unpack(str[start:end])
        val1.mbNormalAndDepthChanged = bool(val1.mbNormalAndDepthChanged)
        start = end
        end += 32
        val1.mDescriptor = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mfMinDistance, _x.mfMaxDistance, _x.mbMultiUse,) = _get_struct_HBH2B2fB().unpack(str[start:end])
        val1.mbBad = bool(val1.mbBad)
        val1.mbMultiUse = bool(val1.mbMultiUse)
        self.MapPoints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.MPUpdates = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.MPred()
        _x = val1
        start = end
        end += 10
        (_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck,) = _get_struct_IBIB().unpack(str[start:end])
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 12
        val1.mPosPred = _get_struct_3f().unpack(str[start:end])
        start = end
        end += 12
        val1.mPosPar = _get_struct_3f().unpack(str[start:end])
        _x = val1
        start = end
        end += 10
        (_x.mbNormalAndDepthChanged, _x.mbServerBA, _x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mbMultiUse,) = _get_struct_2BHBH3B().unpack(str[start:end])
        val1.mbNormalAndDepthChanged = bool(val1.mbNormalAndDepthChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        val1.mbBad = bool(val1.mbBad)
        val1.mbMultiUse = bool(val1.mbMultiUse)
        self.MPUpdates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sH'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.vAckKFs = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.vAckMPs = s.unpack(str[start:end])
      _x = self
      start = end
      end += 9
      (_x.WeakAckKF, _x.WeakAckMP, _x.ClosestKf_Id, _x.ClosestKf_ClientId,) = _get_struct_HIHB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.mMsgId
      buff.write(_get_struct_I().pack(_x))
      length = len(self.Keyframes)
      buff.write(_struct_I.pack(length))
      for val1 in self.Keyframes:
        _x = val1
        buff.write(_get_struct_BHBIdB2h8fh().pack(_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.dTimestamp, _x.mbAck, _x.mnGridCols, _x.mnGridRows, _x.mfGridElementWidthInv, _x.mfGridElementHeightInv, _x.fx, _x.fy, _x.cx, _x.cy, _x.invfx, _x.invfy, _x.N))
        length = len(val1.mvKeysUn)
        buff.write(_struct_I.pack(length))
        for val2 in val1.mvKeysUn:
          _x = val2
          buff.write(_get_struct_2fBfBb().pack(_x.fPoint2f_x, _x.fPoint2f_y, _x.size, _x.angle, _x.response, _x.octave))
        length = len(val1.mDescriptors)
        buff.write(_struct_I.pack(length))
        for val2 in val1.mDescriptors:
          _x = val2.mDescriptor
          # - if encoded as a list instead, serialize as bytes instead of string
          if type(_x) in [list, tuple]:
            buff.write(_get_struct_32B().pack(*_x))
          else:
            buff.write(_get_struct_32s().pack(_x))
        buff.write(val1.mTcpred.tostring())
        buff.write(val1.mTcpar.tostring())
        _x = val1
        buff.write(_get_struct_2B().pack(_x.mbPoseChanged, _x.mbServerBA))
        buff.write(val1.mT_SC.tostring())
        _x = val1
        buff.write(_get_struct_b2f().pack(_x.mnScaleLevels, _x.mfScaleFactor, _x.mfLogScaleFactor))
        buff.write(val1.mvScaleFactors.tostring())
        buff.write(val1.mvLevelSigma2.tostring())
        buff.write(val1.mvInvLevelSigma2.tostring())
        _x = val1
        buff.write(_get_struct_4h().pack(_x.mnMinX, _x.mnMinY, _x.mnMaxX, _x.mnMaxY))
        buff.write(val1.mK.tostring())
        length = len(val1.mvpMapPoints_Ids)
        buff.write(_struct_I.pack(length))
        pattern = '<%sI'%length
        buff.write(val1.mvpMapPoints_Ids.tostring())
        _x = val1.mvpMapPoints_ClientIds
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.mvpMapPoints_VectId)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(val1.mvpMapPoints_VectId.tostring())
        _x = val1
        buff.write(_get_struct_HBH2B().pack(_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbBad))
      length = len(self.KFUpdates)
      buff.write(_struct_I.pack(length))
      for val1 in self.KFUpdates:
        _x = val1
        buff.write(_get_struct_HBIB().pack(_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck))
        buff.write(val1.mTcpred.tostring())
        buff.write(val1.mTcpar.tostring())
        _x = val1
        buff.write(_get_struct_HBH3B().pack(_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbServerBA, _x.mbBad))
      length = len(self.MapPoints)
      buff.write(_struct_I.pack(length))
      for val1 in self.MapPoints:
        _x = val1
        buff.write(_get_struct_BIBIh2B().pack(_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.mnFirstKFid, _x.mnFirstKfClientId, _x.mbAck))
        buff.write(val1.mPosPred.tostring())
        buff.write(val1.mPosPar.tostring())
        _x = val1
        buff.write(_get_struct_2B().pack(_x.mbPoseChanged, _x.mbServerBA))
        length = len(val1.mObservations_KFIDs)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(val1.mObservations_KFIDs.tostring())
        _x = val1.mObservations_KFClientIDs
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.mObservations_n)
        buff.write(_struct_I.pack(length))
        pattern = '<%sH'%length
        buff.write(val1.mObservations_n.tostring())
        buff.write(val1.mNormalVector.tostring())
        _x = val1.mbNormalAndDepthChanged
        buff.write(_get_struct_B().pack(_x))
        _x = val1.mDescriptor
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(_get_struct_32B().pack(*_x))
        else:
          buff.write(_get_struct_32s().pack(_x))
        _x = val1
        buff.write(_get_struct_HBH2B2fB().pack(_x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mfMinDistance, _x.mfMaxDistance, _x.mbMultiUse))
      length = len(self.MPUpdates)
      buff.write(_struct_I.pack(length))
      for val1 in self.MPUpdates:
        _x = val1
        buff.write(_get_struct_IBIB().pack(_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck))
        buff.write(val1.mPosPred.tostring())
        buff.write(val1.mPosPar.tostring())
        _x = val1
        buff.write(_get_struct_2BHBH3B().pack(_x.mbNormalAndDepthChanged, _x.mbServerBA, _x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mbMultiUse))
      length = len(self.vAckKFs)
      buff.write(_struct_I.pack(length))
      pattern = '<%sH'%length
      buff.write(self.vAckKFs.tostring())
      length = len(self.vAckMPs)
      buff.write(_struct_I.pack(length))
      pattern = '<%sI'%length
      buff.write(self.vAckMPs.tostring())
      _x = self
      buff.write(_get_struct_HIHB().pack(_x.WeakAckKF, _x.WeakAckMP, _x.ClosestKf_Id, _x.ClosestKf_ClientId))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.Keyframes is None:
        self.Keyframes = None
      if self.KFUpdates is None:
        self.KFUpdates = None
      if self.MapPoints is None:
        self.MapPoints = None
      if self.MPUpdates is None:
        self.MPUpdates = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (self.mMsgId,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.Keyframes = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.KF()
        _x = val1
        start = end
        end += 55
        (_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.dTimestamp, _x.mbAck, _x.mnGridCols, _x.mnGridRows, _x.mfGridElementWidthInv, _x.mfGridElementHeightInv, _x.fx, _x.fy, _x.cx, _x.cy, _x.invfx, _x.invfy, _x.N,) = _get_struct_BHBIdB2h8fh().unpack(str[start:end])
        val1.bSentOnce = bool(val1.bSentOnce)
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.mvKeysUn = []
        for i in range(0, length):
          val2 = ccmslam_msgs.msg.CvKeyPoint()
          _x = val2
          start = end
          end += 15
          (_x.fPoint2f_x, _x.fPoint2f_y, _x.size, _x.angle, _x.response, _x.octave,) = _get_struct_2fBfBb().unpack(str[start:end])
          val1.mvKeysUn.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.mDescriptors = []
        for i in range(0, length):
          val2 = ccmslam_msgs.msg.Descriptor()
          start = end
          end += 32
          val2.mDescriptor = str[start:end]
          val1.mDescriptors.append(val2)
        start = end
        end += 64
        val1.mTcpred = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=16)
        start = end
        end += 64
        val1.mTcpar = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=16)
        _x = val1
        start = end
        end += 2
        (_x.mbPoseChanged, _x.mbServerBA,) = _get_struct_2B().unpack(str[start:end])
        val1.mbPoseChanged = bool(val1.mbPoseChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        start = end
        end += 64
        val1.mT_SC = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=16)
        _x = val1
        start = end
        end += 9
        (_x.mnScaleLevels, _x.mfScaleFactor, _x.mfLogScaleFactor,) = _get_struct_b2f().unpack(str[start:end])
        start = end
        end += 32
        val1.mvScaleFactors = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=8)
        start = end
        end += 32
        val1.mvLevelSigma2 = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=8)
        start = end
        end += 32
        val1.mvInvLevelSigma2 = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=8)
        _x = val1
        start = end
        end += 8
        (_x.mnMinX, _x.mnMinY, _x.mnMaxX, _x.mnMaxY,) = _get_struct_4h().unpack(str[start:end])
        start = end
        end += 36
        val1.mK = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=9)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sI'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mvpMapPoints_Ids = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mvpMapPoints_ClientIds = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mvpMapPoints_VectId = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
        _x = val1
        start = end
        end += 7
        (_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbBad,) = _get_struct_HBH2B().unpack(str[start:end])
        val1.mbBad = bool(val1.mbBad)
        self.Keyframes.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.KFUpdates = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.KFred()
        _x = val1
        start = end
        end += 8
        (_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck,) = _get_struct_HBIB().unpack(str[start:end])
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 64
        val1.mTcpred = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=16)
        start = end
        end += 64
        val1.mTcpar = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=16)
        _x = val1
        start = end
        end += 8
        (_x.mpPred_KfId, _x.mpPred_KfClientId, _x.mpPar_KfId, _x.mpPar_KfClientId, _x.mbServerBA, _x.mbBad,) = _get_struct_HBH3B().unpack(str[start:end])
        val1.mbServerBA = bool(val1.mbServerBA)
        val1.mbBad = bool(val1.mbBad)
        self.KFUpdates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.MapPoints = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.MP()
        _x = val1
        start = end
        end += 14
        (_x.bSentOnce, _x.mnId, _x.mClientId, _x.mUniqueId, _x.mnFirstKFid, _x.mnFirstKfClientId, _x.mbAck,) = _get_struct_BIBIh2B().unpack(str[start:end])
        val1.bSentOnce = bool(val1.bSentOnce)
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 12
        val1.mPosPred = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
        start = end
        end += 12
        val1.mPosPar = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
        _x = val1
        start = end
        end += 2
        (_x.mbPoseChanged, _x.mbServerBA,) = _get_struct_2B().unpack(str[start:end])
        val1.mbPoseChanged = bool(val1.mbPoseChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mObservations_KFIDs = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mObservations_KFClientIDs = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sH'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.mObservations_n = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
        start = end
        end += 12
        val1.mNormalVector = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
        start = end
        end += 1
        (val1.mbNormalAndDepthChanged,) = _get_struct_B().unpack(str[start:end])
        val1.mbNormalAndDepthChanged = bool(val1.mbNormalAndDepthChanged)
        start = end
        end += 32
        val1.mDescriptor = str[start:end]
        _x = val1
        start = end
        end += 16
        (_x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mfMinDistance, _x.mfMaxDistance, _x.mbMultiUse,) = _get_struct_HBH2B2fB().unpack(str[start:end])
        val1.mbBad = bool(val1.mbBad)
        val1.mbMultiUse = bool(val1.mbMultiUse)
        self.MapPoints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.MPUpdates = []
      for i in range(0, length):
        val1 = ccmslam_msgs.msg.MPred()
        _x = val1
        start = end
        end += 10
        (_x.mnId, _x.mClientId, _x.mUniqueId, _x.mbAck,) = _get_struct_IBIB().unpack(str[start:end])
        val1.mbAck = bool(val1.mbAck)
        start = end
        end += 12
        val1.mPosPred = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
        start = end
        end += 12
        val1.mPosPar = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=3)
        _x = val1
        start = end
        end += 10
        (_x.mbNormalAndDepthChanged, _x.mbServerBA, _x.mpPredKFId, _x.mpPredKFClientId, _x.mpParKFId, _x.mpParKFClientId, _x.mbBad, _x.mbMultiUse,) = _get_struct_2BHBH3B().unpack(str[start:end])
        val1.mbNormalAndDepthChanged = bool(val1.mbNormalAndDepthChanged)
        val1.mbServerBA = bool(val1.mbServerBA)
        val1.mbBad = bool(val1.mbBad)
        val1.mbMultiUse = bool(val1.mbMultiUse)
        self.MPUpdates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sH'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.vAckKFs = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sI'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.vAckMPs = numpy.frombuffer(str[start:end], dtype=numpy.uint32, count=length)
      _x = self
      start = end
      end += 9
      (_x.WeakAckKF, _x.WeakAckMP, _x.ClosestKf_Id, _x.ClosestKf_ClientId,) = _get_struct_HIHB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_16f = None
def _get_struct_16f():
    global _struct_16f
    if _struct_16f is None:
        _struct_16f = struct.Struct("<16f")
    return _struct_16f
_struct_2B = None
def _get_struct_2B():
    global _struct_2B
    if _struct_2B is None:
        _struct_2B = struct.Struct("<2B")
    return _struct_2B
_struct_2BHBH3B = None
def _get_struct_2BHBH3B():
    global _struct_2BHBH3B
    if _struct_2BHBH3B is None:
        _struct_2BHBH3B = struct.Struct("<2BHBH3B")
    return _struct_2BHBH3B
_struct_2fBfBb = None
def _get_struct_2fBfBb():
    global _struct_2fBfBb
    if _struct_2fBfBb is None:
        _struct_2fBfBb = struct.Struct("<2fBfBb")
    return _struct_2fBfBb
_struct_32B = None
def _get_struct_32B():
    global _struct_32B
    if _struct_32B is None:
        _struct_32B = struct.Struct("<32B")
    return _struct_32B
_struct_32s = None
def _get_struct_32s():
    global _struct_32s
    if _struct_32s is None:
        _struct_32s = struct.Struct("<32s")
    return _struct_32s
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_3f = None
def _get_struct_3f():
    global _struct_3f
    if _struct_3f is None:
        _struct_3f = struct.Struct("<3f")
    return _struct_3f
_struct_4h = None
def _get_struct_4h():
    global _struct_4h
    if _struct_4h is None:
        _struct_4h = struct.Struct("<4h")
    return _struct_4h
_struct_8f = None
def _get_struct_8f():
    global _struct_8f
    if _struct_8f is None:
        _struct_8f = struct.Struct("<8f")
    return _struct_8f
_struct_9f = None
def _get_struct_9f():
    global _struct_9f
    if _struct_9f is None:
        _struct_9f = struct.Struct("<9f")
    return _struct_9f
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_BHBIdB2h8fh = None
def _get_struct_BHBIdB2h8fh():
    global _struct_BHBIdB2h8fh
    if _struct_BHBIdB2h8fh is None:
        _struct_BHBIdB2h8fh = struct.Struct("<BHBIdB2h8fh")
    return _struct_BHBIdB2h8fh
_struct_BIBIh2B = None
def _get_struct_BIBIh2B():
    global _struct_BIBIh2B
    if _struct_BIBIh2B is None:
        _struct_BIBIh2B = struct.Struct("<BIBIh2B")
    return _struct_BIBIh2B
_struct_HBH2B = None
def _get_struct_HBH2B():
    global _struct_HBH2B
    if _struct_HBH2B is None:
        _struct_HBH2B = struct.Struct("<HBH2B")
    return _struct_HBH2B
_struct_HBH2B2fB = None
def _get_struct_HBH2B2fB():
    global _struct_HBH2B2fB
    if _struct_HBH2B2fB is None:
        _struct_HBH2B2fB = struct.Struct("<HBH2B2fB")
    return _struct_HBH2B2fB
_struct_HBH3B = None
def _get_struct_HBH3B():
    global _struct_HBH3B
    if _struct_HBH3B is None:
        _struct_HBH3B = struct.Struct("<HBH3B")
    return _struct_HBH3B
_struct_HBIB = None
def _get_struct_HBIB():
    global _struct_HBIB
    if _struct_HBIB is None:
        _struct_HBIB = struct.Struct("<HBIB")
    return _struct_HBIB
_struct_HIHB = None
def _get_struct_HIHB():
    global _struct_HIHB
    if _struct_HIHB is None:
        _struct_HIHB = struct.Struct("<HIHB")
    return _struct_HIHB
_struct_IBIB = None
def _get_struct_IBIB():
    global _struct_IBIB
    if _struct_IBIB is None:
        _struct_IBIB = struct.Struct("<IBIB")
    return _struct_IBIB
_struct_b2f = None
def _get_struct_b2f():
    global _struct_b2f
    if _struct_b2f is None:
        _struct_b2f = struct.Struct("<b2f")
    return _struct_b2f
